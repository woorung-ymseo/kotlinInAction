# 2장 - 코틀린 기초
## 2.1 기본 요소 : 함수와 변수

---

### 2.1.1  Hello, world!

~~~kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
~~~

- 함수를 선언할 때 `fun` 키워드를 사용
- `파라미터 이름 뒤에 파라미터의 타입을 작성`, 변수를 선언할 때도 마찬가지 방식으로 지정한다.
- `함수를 최상위 수준에 정의`할 수 있다.
  - 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- 배열도 일반적인 클래스이다. 
  - 코틀린에서는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- 코틀린 표준 라이브러리는 표준 자바 라이브러리를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다.
  - println 도 그런 함수중 하나다.
- 줄 끝에 `세미콜론(;)을 붙이지 않아도 된다`.

---

### 2.1.2 함수

> 결과를 반환하는 함수의 경우 반환 값의 타입을 어디에 지정해야 할까?

~~~kotlin
fun max(a: Int, b: Int) : Int {
    return if (a > b) a else b
}
~~~

- 함수 선언은 `fun` 키워드로 시작한다.
- fun 다음 이름이 온다.
- 함수 이름 뒤에 괄호에는 파라미터 목록이 온다.
- `반환 타입`은 파라미터 목록의 닫는 괄호 다음에 온다
  - 괄호와 반환타입 사이를 `콜론(:)`으로 구분한다
- 코트린 if는 `문장`(값을 만들어내지 못하는)이 아니고 `식`(결과를 만드는) 이다.

> 문과 식의 구분

- `식`은 `값`을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다
- `문`은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며, `아무런 값을 만들어내지 않는다`
- 자바에서는 모든 제어 구조가 문이다
- 코틀린에서는 루프를 제외한 대부분의 제오 구조가 식이다

#### 식이 본문인 함수

- 위 함수 본문은 if 식 하나로 이뤄져있다.
- 중괄호를 없애고 return을 제거하면서 등호를 식 앞에 붙이면 더 간결하게 표현할 수 있다.

~~~kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
~~~

> 반환 타입을 생략할 수 있는 이유는 무엇일까?

- 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.
  - `타입추론`
- 식이 본문인 함수의 반환 타입만 생략이 가능하다.
- 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return 문을 사용해 반환 값을 명시해야 한다.

---

### 2.1.3 변수

> 자바에서는 변수를 선언할 때 타입이 맨 앞에 온다. <br>
> 코틀린에서는 타입 지정을 생략하는 경우가 흔하다. <br>
> 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략을 허용한다.

~~~kotlin
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42
var answer2: Int = 42
~~~

- 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 변수 타입을 지정한다.
- 부동소수점 상수를 사용한다면 변수 타입은 Double이 된다.
    
~~~kotlin
val yearsToCompute = 7.5e6
~~~

- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.

~~~kotlin
val answer:Int
answer = 42
~~~

- 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다.
- 이런 경우 반드시 타입을 지정해야 한다.

#### 변경 가능한 변수와 변경 불가능한 변수

- val
  - 변경불가능한 (immutable) 참조를 저장하는 변수
  - 초기화 후에 재대입 불가능
  - 자바로 치면 final 변수에 해당
- var
  - 변경가능 (mutable)한 참조
  - 자바의 일반 변수에 해당

- 기본적으로는 모든 변수를 val 키워드를 사용해 선언하고, 필요할 때에만 var로 변경해야 한다.
- 조건에 따라 val 값을 다른 여러 값으로 초기화 할 수도 있다.

~~~kotlin
val message:String
if (canperfomPeration()) {
    message = "Success"
    // ... 기타 등등
} else {
    message = "Failed"
}
~~~

- val 참조 자체는 불변일지라도, 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

~~~kotlin
val languages = arrayListOf("java") // 불변 참조를 선언
languages.add("Kotlin") // 참조가 가리키는 객체 내부를 변경
~~~

- var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다. 아래와 같은 코드는 컴파일 할 수 없다.

~~~kotlin
var answer = 42
answer = "no answer"
~~~

- 컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론한다.
- 선언 이후 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.
- 어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면, 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형변환 해야 한다.

> 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

~~~kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
~~~

- 이 예제는 문자열 템플릿 이라는 기능을 보여준다.
- name 이라는 변수를 선언하고, 문자열 리터럴 안에서 변수를 사용했다.
- 코틀린에서도 변수를 문자열 안에 사용할 수 있다.
- 사용시 변수 앞에 $를 추가해야 한다.
- 이 문자열 템플릿은 자바의 문자열 접합연산 ("Hello, " + name + "!") 과 동일한 기능을 하지만 좀 더 간결하다.
- 컴파일러는 각 식을 정적으로 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.
- $ 문자를 문자열에 넣고 싶으면 println("\$x") 와 같이 \를 사용해 $를 이스케이프 시켜야 한다.
- 문자열 템플릿 안에 사용할 수 있는 대상은 간단한 변수 이름만으로 한정되지 않는다. 복작한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.

~~~kotlin
fun main(args: Array<String>) {
    if (args.size > 0) {
        println("Hello, ${args[0]}!")
    }
}
~~~

#### 한글을 문자열 템플릿에서 사용할 경우 주의할 점
- 문자열 템플릿 안에 $ 로 변수를 지정할 때 변수명 바로 뒤에 한글을 붙여서 사용하면 코틀린 컴파일러는 영문자와 한글을 한꺼번에 식별자로 인식해서 unresolved reference 오류를 발생시킨다.
  - ex) $name님 반가워요 -> 에러
- 해결방법은 ${name}님 반가워요 처럼 변수 이름을 {}로 감싸는 것이다.
- 문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 ${name} 처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다.
- 중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.

~~~kotlin
fun main(args: Array<String>) {
    println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
}
~~~

## 2.2 클래스와 프로퍼티